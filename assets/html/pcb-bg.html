<style>
    :root {
        --pcb-trace-color: #37d67a;
        --pcb-dot-color: #fff;
    }
    .pcb-bg-svg polyline {
        stroke: var(--pcb-trace-color);
    }
    .pcb-bg-svg circle {
        fill: var(--pcb-dot-color);
    }
</style>
<div id="pcb-bg" style="position:fixed; inset:0; z-index:-1; width:100vw; height:100vh; overflow:hidden;">
    <svg class="pcb-bg-svg" width="100%" height="100%" viewBox="0 0 1200 800" preserveAspectRatio="none" style="display:block;">
        <polyline id="trace1" points="0,150 300,150 300,650 1200,650" stroke-width="12" fill="none"/>
        <polyline id="trace2" points="0,400 500,400 500,100 1200,100" stroke-width="12" fill="none"/>
        <polyline id="trace3" points="0,700 700,700 700,300 1200,300" stroke-width="12" fill="none"/>
        <circle id="dot1" r="14" opacity="0.85" />
        <circle id="dot2" r="14" opacity="0.85" />
        <circle id="dot3" r="14" opacity="0.85" />
        <defs>
            <filter id="glow-dot" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="8" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
    </svg>
</div>
<script>
function interpolatePoints(points, t) {
    let total = 0, segLengths = [];
    for (let i = 0; i < points.length - 1; i++) {
        let dx = points[i+1][0] - points[i][0];
        let dy = points[i+1][1] - points[i][1];
        let len = Math.sqrt(dx*dx + dy*dy);
        segLengths.push(len);
        total += len;
    }
    let dist = t * total;
    let acc = 0;
    for (let i = 0; i < segLengths.length; i++) {
        if (acc + segLengths[i] >= dist) {
            let segT = (dist - acc) / segLengths[i];
            let x = points[i][0] + (points[i+1][0] - points[i][0]) * segT;
            let y = points[i][1] + (points[i+1][1] - points[i][1]) * segT;
            return {x, y};
        }
        acc += segLengths[i];
    }
    return {x: points[points.length-1][0], y: points[points.length-1][1]};
}

function animateRect(rectId, points, duration, size) {
    function step(ts) {
        let t = ((ts % duration) / duration);
        let pos = interpolatePoints(points, t);
        let rect = document.getElementById(rectId);
        if (rect) {
            rect.setAttribute('width', size);
            rect.setAttribute('height', size);
            rect.setAttribute('x', pos.x - size/2);
            rect.setAttribute('y', pos.y - size/2);
        }
        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

document.addEventListener('DOMContentLoaded', function() {
    animateRect('dot1', [[0,150],[300,150],[300,650],[1200,650]], 4000, 12);
    animateRect('dot2', [[0,400],[500,400],[500,100],[1200,100]], 5000, 12);
    animateRect('dot3', [[0,700],[700,700],[700,300],[1200,300]], 3500, 12);
});
</script>