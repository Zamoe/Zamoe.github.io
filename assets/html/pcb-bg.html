<style>
    :root {
        --pcb-trace-color: #0b4a26;
        --pcb-dot-color: #ffffff39;
        --pcb-dot-size: 5;
    }
    .pcb-bg-svg polyline {
        stroke: var(--pcb-trace-color);
    }
    .pcb-bg-svg circle {
        fill: var(--pcb-dot-color);
        filter: url(#glow-dot);
        opacity: 0.85;
        transition: fill 0.2s;
    }
</style>
<div id="pcb-bg" style="position:fixed; inset:0; z-index:-1; width:100vw; height:100vh; overflow:hidden;">
    <svg class="pcb-bg-svg" width="100%" height="100%" viewBox="0 0 1200 800" preserveAspectRatio="none">
        <polyline id="trace1" points="0,150 300,150 300,650 1200,650" stroke-width="12" fill="none"/>
        <polyline id="trace2" points="0,400 500,400 500,100 1200,100" stroke-width="12" fill="none"/>
        <polyline id="trace3" points="0,700 700,700 700,300 1200,300" stroke-width="12" fill="none"/>
        <polyline id="trace4" points="1200,50 900,50 900,750 0,750" stroke-width="12" fill="none"/>
        <polyline id="trace5" points="1200,500 1000,500 1000,200 0,200" stroke-width="12" fill="none"/>
        <circle id="dot1" r="15" cx="0" cy="150"/>
        <circle id="dot2" r="15" cx="0" cy="400"/>
        <circle id="dot3" r="15" cx="0" cy="700"/>
        <circle id="dot4" r="15" cx="1200" cy="50"/>
        <circle id="dot5" r="15" cx="1200" cy="500"/>
        <defs>
            <filter id="glow-dot" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="8" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
    </svg>
</div>
<script>
function interpolatePoints(points, t) {
    let total = 0, segLengths = [];
    for (let i = 0; i < points.length - 1; i++) {
        let dx = points[i+1][0] - points[i][0];
        let dy = points[i+1][1] - points[i][1];
        let len = Math.sqrt(dx*dx + dy*dy);
        segLengths.push(len);
        total += len;
    }
    let dist = t * total;
    let acc = 0;
    for (let i = 0; i < segLengths.length; i++) {
        if (acc + segLengths[i] >= dist) {
            let segT = (dist - acc) / segLengths[i];
            let x = points[i][0] + (points[i+1][0] - points[i][0]) * segT;
            let y = points[i][1] + (points[i+1][1] - points[i][1]) * segT;
            return {x, y};
        }
        acc += segLengths[i];
    }
    return {x: points[points.length-1][0], y: points[points.length-1][1]};
}

function getCSSVariable(name, fallback) {
    let val = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    return val ? parseFloat(val) : fallback;
}

function animateDot(dotId, points, duration) {
    const size = getCSSVariable('--pcb-dot-size', 15);
    function step(ts) {
        let t = ((ts % duration) / duration);
        let pos = interpolatePoints(points, t);
        let dot = document.getElementById(dotId);
        if (dot) {
            dot.setAttribute('r', size);
            dot.setAttribute('cx', pos.x);
            dot.setAttribute('cy', pos.y);
        }
        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

document.addEventListener('DOMContentLoaded', function() {
    animateDot('dot1', [[0,150],[300,150],[300,650],[1200,650]], 4000);
    animateDot('dot2', [[0,400],[500,400],[500,100],[1200,100]], 5000);
    animateDot('dot3', [[0,700],[700,700],[700,300],[1200,300]], 3500);
    animateDot('dot4', [[1200,50],[900,50],[900,750],[0,750]], 4200);
    animateDot('dot5', [[1200,500],[1000,500],[1000,200],[0,200]], 3800);
});
</script>